<!DOCTYPE html>
<!--
    TODO:
        - scale
        - response errors
        - preloader
        - erase old regions after new image upladed
-->
<html>
  <head>
    <meta charset="utf-8" />
    <title>Атомик Хак 2.0 :: team9</title>

    <style>

        .conf {
            color: black;
            background: white;
            position: absolute;
        }

        .region {
            border: 2px solid yellow;
            position: absolute;
        }

        .region:hover {
            border: 2px solid red;
            position: absolute;
        }

        .centered {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

    </style>

  </head>
  <body>
    <h1>Атомик Хак 2.0 :: team9</h1>
    <button id="startButton">Start Stream</button>
    <hr> 
    <video id="video" width="640" height="480" autoplay style="display: none"></video>
    <div id='container' style="position: relative;">
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>


  </body>

  <script>
    BACKEND = '{{ BACKEND }}';

    console.log('BACKEND is: ' + BACKEND);

    function removeElementsByClass(className){
        const elements = document.getElementsByClassName(className);
        while(elements.length > 0){
            elements[0].parentNode.removeChild(elements[0]);
        }
    }

    function onResponse(response)
    {

        removeElementsByClass('region');
        removeElementsByClass('conf');

        results = response['results']['result_array_box'];

        container = document.getElementById('container');

        for(i=0;i<results.length;i++)
        {
            el = document.createElement('div');

            el.setAttribute('class', 'region')

            l = Math.round(response['results']['result_array_box'][i][0]*document.scale_w);
            t = Math.round(response['results']['result_array_box'][i][1]*document.scale_h); 
            w = Math.round(response['results']['result_array_box'][i][2]*document.scale_w) - l;
            h = Math.round(response['results']['result_array_box'][i][3]*document.scale_h) - t;

            console.log(l, t, w, h);

            el.style.left   = l + 'px';
            el.style.top    = t + 'px';
            el.style.width  = w + 'px';
            el.style.height = h + 'px';

            container.appendChild(el);

            conf = document.createElement('span');

            conf.setAttribute('class', 'conf')

            conf.innerText = 'Conf: ' + parseFloat(response['results']['confidence'][i]).toFixed(4);

            conf.style.left   = l + 'px';
            conf.style.top    = (t - 25) + 'px';

            container.appendChild(conf);

            cls = document.createElement('span');

            cls.setAttribute('class', 'conf')

            cls.innerText = 'Class: ' + response['results']['classes'][i];

            cls.style.left = (l + w + 5) + 'px';
            cls.style.top  = t + 'px';

            container.appendChild(cls);
        }

    }

document.getElementById('startButton').addEventListener('click', async () => {
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const context = canvas.getContext('2d');

    //alert(await navigator.mediaDevices)

    // Запуск видеопотока с камеры
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        video.srcObject = stream;
    } catch (err) {
        alert('Error accessing camera: ' + err);
        return;
    }

    // Функция для отправки кадра на сервер и получения результатов
    async function sendFrame() {
        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        const imageData = canvas.toDataURL('image/jpeg');

        let file = null;

        canvas.toBlob((blob) => {
            file = new File([blob], "fileName.jpg", { type: "image/jpeg" })

            const xhr = new XMLHttpRequest();

            const fileData = new FormData();
            fileData.append("file", file);

            xhr.onload = function (r) {

                response = JSON.parse(xhr.responseText);

                console.log(response);

                //if ( response.success )
                    onResponse(response);
                //else
                //   alert(response.message);

            };

            xhr.open("POST", BACKEND + "/inference?model_name=yolov8&model_text_AI_name=yolov8&model_text_image_AI_name=yolov8&run_AI_assistante=false", true);
            xhr.send(fileData);

            }, 'image/jpeg');

        console.log('sendFrame')

        requestAnimationFrame(sendFrame);
    }

    // Функция для отображения ограничивающих рамок
    function drawBoundingBoxes(results) {
        context.clearRect(0, 0, canvas.width, canvas.height);
        context.drawImage(video, 0, 0, canvas.width, canvas.height);

        results.result_array_box.forEach((box, index) => {
            context.strokeStyle = 'red';
            context.lineWidth = 2;
            context.strokeRect(box[0], box[1], box[2] - box[0], box[3] - box[1]);

            context.fillStyle = 'red';
            context.font = '20px Arial';
            context.fillText(results.classes[index], box[0], box[1] - 10);
        });
    }

    // Начать отправку кадров
    requestAnimationFrame(sendFrame);
});

    

</script>
</html>
